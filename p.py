# -*- coding: utf-8 -*-
"""Page Rank steady state.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fl38a6OqgVx2Shyh9gdc7aM8LDfN4GfF
"""

#going through hyperlinks: 1-alpha
#going to any random page: alpha
import numpy as np
import math

# normalize the matrix (make it a probability matrix (all cols sum to 1))
#eigen method, col sum is taken
def normalizeAdjacencyMatrix(A):
    n = len(A) # n = num of rows/cols in A
    for j in range(len(A[0])):
        sumOfCol = 0
        for i in range(len(A)):
            sumOfCol += A[i][j]

        if sumOfCol == 0: # adjust for dangling nodes (columns of zeros)
            for val in range(n):
                A[val][j] = 1/n
        else:
            for val in range(n):
                A[val][j] = (A[val][j] / sumOfCol)
    return A

#for power iteration, row sum is taken
def normalizeAdjacencyMatrix2(A):
    n = len(A) # n = num of rows/cols in A
    for i in range(len(A)):
        sumOfrow = 0
        for j in range(len(A[0])):
            sumOfrow += A[i][j]

        if sumOfrow == 0: # adjust for dangling nodes (columns of zeros)
            for val in range(n):
                A[i][val] = 1/n
        else:
            for val in range(n):
                A[i][val] = (A[i][val] / sumOfrow)
    return A

# implement damping matrix using formula
# M = dA + (1-d)(1/n)Q, where Q is an array of 1's and d is the damping factor
def dampingMatrix(A):
    n = len(A) # n = num of rows/cols in A
    dampingFactor = 0.5
    Q = [[1/n]*n]*n
    arrA = np.array(A)
    arrQ = np.array(Q)
    arrM = np.add((dampingFactor)*arrQ, (1-dampingFactor)*arrA) # create damping matrix
    return arrM

# find eigenvector corresponding to eigenvalue 1
def findSteadyState(M, n):
    # find eigenvectors
    evectors = np.linalg.eig(M)[1]

    # find eigenvalues
    eigenValues = np.linalg.eig(M)[0]
    lstEVals = []
    for val in eigenValues:
        lstEVals.append(round(val))

    # find eigenvector with eigenvalue 1
    idxWithEval1 = lstEVals.index(1)
    steadyStateVector = evectors[:, idxWithEval1]

    # normalize steady state vector so its components sum to 1
    lstVersionSteadyState = []
    sumOfComps = 0
    returnVector = []
    for val in steadyStateVector:
        sumOfComps += val
        lstVersionSteadyState.append(val)
    for val in lstVersionSteadyState:
        returnVector.append(val/sumOfComps)

    return returnVector

def pageRank(A):
    n = len(A) # n = num of rows/cols in A
    A = normalizeAdjacencyMatrix(A)
    M = dampingMatrix(A)

    # find steady state vector
    steadyStateVectorOfA = findSteadyState(M, n)
    return steadyStateVectorOfA

def convergence(A1):
    n = len(A1) # n = num of rows/cols in A
    A = normalizeAdjacencyMatrix2(A1)
    M = dampingMatrix(A)
    Intial_arr = [1/n for i in range(n)]
    Intial_vector = np.array(Intial_arr)

    Prev = Intial_vector
    Page_rank = Intial_vector

    while(1):
      flag = 0
      Prev = Page_rank
      Page_rank = np.matmul(Prev,M)

      print("Previous value is ",Prev)
      print("Current value is ",Page_rank)
      print("\n")

      if(np.all(np.abs(Page_rank-Prev)<0.01)):
        break


# TEST CASES
print("\nPage Rank Examples")
# 1) (corresponds to directed graph (1) on readme.md)
matrix1 = [ [0, 1, 0],
            [1, 0, 1],
            [0, 1, 0]]
print("1) matrix 1 = ", matrix1)
print("steady state vector: ")
print(pageRank(matrix1))
print("\n")
print("using power iteration:")
print(convergence(matrix1))
# expected output: [0.077, 0.054, 0.441, 0.429]
'''
# 2)

matrix2 = [ [0, 0, 1, 0, 0, 0, 0, 0],
            [1, 0, 0, 1, 0, 0, 0, 0],
            [1, 0, 0, 0, 0, 0, 0, 0],
            [1, 1, 1, 0, 0, 0, 0, 0],
            [0, 1, 0, 0, 0, 1, 0, 0],
            [0, 0, 0, 0, 0, 0, 1, 1],
            [0, 0, 0, 1, 1, 0, 0, 1],
            [0, 0, 0, 0, 0, 1, 0, 0]  ]
matrix2=[ [0,1,0,1],
         [0,0,0,1],
          [0,1,0,0],
          [0,0,1,0]]
print("\n2) matrix 2 = ", matrix2)
print("steady state vector: ")
print(pageRank(matrix2))
# expected output: [0.03037, 0.0536, 0.02735, 0.0617, 0.1621, 0.2836, 0.2419, .1393]
'''